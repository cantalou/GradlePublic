android.aaptOptions.additionalParameters("-P", "${buildDir}/outputs/public.xml")

ext.publicDir = "${rootDir}/public/"
file(publicDir).mkdirs()

ext.publicFile = file("${publicDir}/public.xml")
ext.paddingFile = file("${publicDir}/padding.xml")
ext.skipFile = file("${publicDir}/skip.xml")

afterEvaluate {
    android.applicationVariants.each { variant ->

        def capitalizeName = variant.name.capitalize()

        def mergeTask = tasks.findByName("merge${capitalizeName}Resources")
        def task = tasks.findByName("process${capitalizeName}Resources");
        task.doLast {

            println "\n开始执行keep resource id 任务"
            def valuesDir = "${mergeTask.outputDir}/values"

            def generatedPublic = file("${buildDir}/outputs/public.xml")
            if (!generatedPublic.exists()) {
                println "不存在${generatedPublic}文件"
                return
            }

            def skipItem = [] as HashSet
            skipItem.addAll(getItems(skipFile))
            if (!skipItem.empty) {
                println("存在需要忽略的节点数:${skipItem.size()}")
            }

            if (!publicFile.exists()) {
                println "旧的public.xml文件不存在直接复制一份"
                copy {
                    from generatedPublic
                    into publicDir
                }
                reorderPublicXml skipItem
                println "根据public.xml生成ids.xml文件"
                generateId("${valuesDir}/values.xml")
                return
            }

            //新导出的public节点
            def newItem = []
            newItem.addAll(getItems(generatedPublic))

            //旧的public节点
            def oldItem = []
            def deletedItem = []
            def newItemSet = [] as HashSet
            newItemSet.addAll(newItem)
            getItems(publicFile).each {
                if (skipItem.contains(it)) {
                    //被忽略的节点
                } else if (newItemSet.contains(it)) {
                    oldItem << it
                } else {
                    //旧public文件存在, 但新public文件里面删除的节点
                    deletedItem << it
                }
            }

            def buildType = variant.getBuildType()
            def releaseMode = buildType.isMinifyEnabled() && buildType.name.equalsIgnoreCase("release")

            def padding = getItems(paddingFile)
            println "旧public-padding.xml 文件存在,已有节点${padding.toString()}"

            if (deletedItem.size() > 0) {
                if (releaseMode) {
                    skipItem.addAll(deletedItem)
                    writeSkipXml skipItem
                    writePublicXml oldItem
                    reorderPublicXml skipItem
                    generateId("${valuesDir}/values.xml")
                    println "Release模式下存在删除的节点:${deletedItem.size()}, 将节点添加到skip.xml文件中,skip节点:${skipItem.size()}"
                } else {

                    padding.addAll(deletedItem)
//                    def paddingIds = padding*.id
//                    deletedItem.each {
//                        //clean build的时候,根据重新生成的public.xml计算出来的被删除的节点, 是包含所有被删除的节点(所有版本),padding.xml中包含了以前版本生成的被删除的节点, 这里需要过滤
//                        //对于同一个文件可能删除后又加进来, 或者删除后下次加进来同名但是内容不同,这里根据id进行过滤
//                        if (!paddingIds.contains(it.id)) {
//                            padding << it
//                        }
//                    }
                    writePaddingXml(padding)
                    writePublicXml oldItem
                    generateId("${valuesDir}/values.xml")
                    println "Debug模式下存在被删除的节点, 新版本public.xml 文件删除了${deletedItem.size}个资源, 增加public-padding节点,总数:${padding.size()}"
                }
            }

            def existPublicInValues = file("${valuesDir}/public.xml").exists()
            if (!existPublicInValues) {
                println "values文件夹不存在public.xml文件,需要复制public.xml,padding.xml, ids.xml文件到values文件夹下重新执行process${capitalizeName}Resources task"
                if (!file("${publicDir}/ids.xml").exists()) {
                    println "ids.xml文件不存在重新生成"
                    generateId("${valuesDir}/values.xml")
                }
                copyPublicFilesIntoValuesDir valuesDir
                if (releaseMode) {
                    throw new RuntimeException("Release混淆模式下无法直接Task重新执行, 只拷贝文件到values文件夹下, 需要手动再次执行打包命令(命令中不要包含clean)")
                } else {
                    it.execute()
                }
                return
            }

            def oldSize = oldItem.size() + padding.size() + (releaseMode ? 0 : skipItem.size())
            println "newSize:${newItem.size()},oldSize:${oldItem.size()},paddingSize:${padding.size()},skipSize:${skipItem.size()} containsAll:${newItem.containsAll(oldItem)}"
            if (newItem.size() == oldSize && newItem.containsAll(oldItem)) {
                println "新旧public文件内容相同"
            } else {
                println "values文件夹存在public.xml文件,有新增节点, 直接复制一份"
                if (!padding.empty) {
                    newItem.removeAll { item ->
                        padding.any { it.id.equals(item.id) }
                    }
                }
                writePublicXml newItem
                reorderPublicXml skipItem
                println "重新生成ids.xml文件"
                generateId("${valuesDir}/values.xml")
                copyPublicFilesIntoValuesDir valuesDir
                if (releaseMode) {
                    throw new RuntimeException("Release混淆模式下无法直接Task重新执行, 只拷贝文件到values文件夹下, 需要手动再次执行打包命令(命令中不要包含clean)")
                } else {
                    it.execute()
                }
            }
        }
    }


    task buildJarTask(type: Jar) {

        destinationDir = file("${buildDir}/intermediates/bundles/")
        appendix = ""
        baseName = "androidJar"
        version = "1.0.0"
        classifier = "debug"

        //后缀名
        extension = "jar"
        archiveName = "class.jar"

        //需打包的资源所在的路径集
        def srcClassDir = []
        android.applicationVariants.all { variant ->
            srcClassDir.add("${project.buildDir.absolutePath}/intermediates/classes/${variant.dirName}")
        }
        //初始化资源路径集
        from srcClassDir
        exclude '**/R.class'
        exclude '**/R$*.class'
    }


    if (gradle.startParameter.taskNames.find {
        it.contains("assemble")
    } != null) {
        //第4件事
        android.applicationVariants.all { variant ->
            tasks.each { task ->
                if (task.name.equalsIgnoreCase("assemble" + variant.name)) {
                    task.doLast {
                        println "导出jar包"
                        buildJarTask.execute()
                    }
                }
            }
        }
    }

}
/**
 * 根据public-skip文件的描述删除多余的节点, 重新编号资源id
 * @param items
 * @return
 */
def reorderPublicXml(def skipItem) {

    if (skipItem.isEmpty()) {
        return;
    }

    println "存在skip.xml文件重新排序资源id,从public.xml文件中删除"
    def oldItemMap = [:] as LinkedHashMap
    def oldItem = []
    getItems(publicFile).each {
        if (!skipItem.contains(it)) {
            def list = oldItemMap.get(it.type)
            if (list == null) {
                list = []
                oldItemMap.put(it.type, list)
            }
            list << it
        }
    }
    def paddingIds = getItems(paddingFile).collect { Integer.parseInt(it.id.substring(2), 16) } as HashSet
    oldItemMap.each { k, v ->
        java.util.Collections.sort(v, new Comparator<Item>() {
            @Override
            int compare(Item lhs, Item rhs) {
                return lhs.id.compareTo(rhs.id)
            }
        })
        def newId = Integer.parseInt(v.get(0).id.substring(2), 16) & 0xFFFF0000
        v.each {
            while (paddingIds.contains(newId)) {
                newId++
            }
            it.id = "0x" + Long.toString(newId, 16)
            newId++
            oldItem << it
        }
    }

    def padding = getItems(paddingFile)
    def size = padding.size()
    for (int i = 0; i < padding.size(); i++) {
        def item = padding.get(i)
        def list = oldItemMap.get(item.type)
        if (list != null && list.size() > 0 && Integer.parseInt(item.id.substring(2), 16) > Integer.parseInt(list.get(list.size() - 1).id.substring(2), 16)) {
            padding.remove(i--)
        }
    }
    if (size > padding.size()) {
        writePaddingXml padding
    }

    writePublicXml oldItem
}

def getItems(def file) {
    def padding = []
    def text
    if (file.exists() && !(text = file.getText()).empty) {
        def paddingResources = new XmlSlurper().parseText(text)
        paddingResources.children().each {
            padding << new Item(it)
        }
    }
    padding
}

def writeSkipXml(def items) {
    skipFile.withWriter { out ->
        out.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
        out.println("<resources>")
        items.each {
            out.println("<public name=\"${it.name}\" type=\"${it.type}\" id=\"\"/>")
        }
        out.println("</resources>")
    }
}

def writePaddingXml(def items) {
    paddingFile.withWriter { out ->
        out.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
        out.println("<resources>")
        items.each {
            out.println("<public-padding type=\"${it.type}\" name=\"${it.name}\" start=\"${it.id}\" end=\"${it.id}\" id=\"${it.id}\"/>")
        }
        out.println("</resources>")
    }
}

def writePublicXml(def items) {
    publicFile.withWriter { out ->
        out.println("<?xml version=\"1.0\" encoding=\"utf-8\"?>")
        out.println("<resources>")
        items.each {
            out.println("<public type=\"${it.type}\" name=\"${it.name}\"  id=\"${it.id}\" />")
        }
        out.println("</resources>")
    }
}

def copyPublicFilesIntoValuesDir(def destDir) {
    copy {
        from publicDir
        into destDir
        include 'ids.xml', 'public.xml', 'padding.xml'
    }
}

/**
 * 生成ids.xml文件, 再通过public.xml文件固定这些id值
 *
 * @param valueFile 合并后的资源文件
 * @param skipItem 需要忽略的节点
 * @return
 */
def generateId(def valueFile) {

    if (!publicFile.exists()) {
        return;
    }

    //app中自定义的id和padding里面的id
    def existsIds = []
    [file(valueFile), paddingFile].each {
        if (it.exists()) {
            def content = it.getText()
            if (!content.empty) {
                new XmlSlurper().parseText(content).item.each {
                    def type = it.@type.text()
                    if (type.equals("id")) {
                        def name = it.@name.text()
                        existsIds.add(name)
                    }
                }
            }
        }
    }

    //app自动生成的id
    def ids = []
    def resources = new XmlSlurper().parse(publicFile)
    resources.public.each {
        def type = it.@type.text()
        def name = it.@name.text()
        if (type.equals("id") && !existsIds.contains(name)) {
            ids.add(name)
        }
    }

    def destIds = file("${publicDir}/ids.xml")
    destIds.withWriter { out ->
        out.println "<?xml version=\"1.0\" encoding=\"utf-8\"?>"
        out.println "<resources>"
        ids.each {
            out.println "<item type=\"id\" name=\"${it}\" />"
        }
        out.println "</resources>"
    }
}

class Item {

    def type
    def name
    def id

    Item(def node) {
        this.type = node.@type.text()
        this.name = node.@name.text()
        this.id = node.@id.text()
    }

    boolean equals(o) {
        if (this.is(o)) return true
        if (getClass() != o.class) return false
        Item item = (Item) o
        return name.equals(item.name) && type.equals(item.type)
    }

    int hashCode() {
        return name.hashCode() * 37 + type.hashCode()
    }

    @Override
    public String toString() {
        return "\nItem{" +
                "type=" + type +
                ", name=" + name +
                ", id=" + id +
                '}'
    }
}
